using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Net;
using System.Net.Http;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.InputSystem;
using TMPro;
using Unity.WebRTC;
using System.Linq;

using Debug = System.Diagnostics.Debug;
using System.Collections.Concurrent;

public class PlayerController : MonoBehaviour
{
    private int FRAME_WIDTH = 640;
    private int FRAME_HEIGHT = 480;
    private int MAX_BIT_RATE = 500000; // 500Kbps should do it.

    private const string NODE_DSS_SERVER = "http://127.0.0.1:3000";
    private const string NODE_DSS_MY_USER = "unity";
    private const string NODE_DSS_THEIR_USER = "browser";

    public float speed = 0f;
    public TextMeshProUGUI countText;
    public GameObject winTextObject;

    private Rigidbody rb;
    private int count;
    private float movementX;
    private float movementY;

#pragma warning disable 0649
    [SerializeField] private Camera cam;
#pragma warning restore 0649

    private RTCPeerConnection _pc;
    private WebRTCNodeDssPeer _signaller;

    void Awake()
    {
        WebRTC.Initialize(EncoderType.Software);
    }

    private void OnDestroy()
    {
        _signaller?.Close();
        WebRTC.Dispose();
    }

    // Start is called before the first frame update
    void Start()
    {
        rb = GetComponent<Rigidbody>();
        count = 0;

        SetCountText();
        winTextObject.SetActive(false);

        // Create the peer connection object and start the signalling.
        _pc = CreatePeerConnection();
        _signaller = new WebRTCNodeDssPeer(NODE_DSS_SERVER, NODE_DSS_MY_USER, NODE_DSS_THEIR_USER, _pc);

        var videoStream = cam.CaptureStream(FRAME_WIDTH, FRAME_HEIGHT, MAX_BIT_RATE);
        _pc.AddTrack(videoStream.GetVideoTracks().First());

        StartCoroutine(WebRTC.Update());
        StartCoroutine(_signaller.Start());
    }

    void OnMove(InputValue movementValue)
    {
        Vector2 movementVector = movementValue.Get<Vector2>();

        movementX = movementVector.x;
        movementY = movementVector.y;
    }

    void SetCountText()
    {
        countText.text = "Count: " + count.ToString();

        if (count >= 10)
        {
            winTextObject.SetActive(true);
        }
    }

    void FixedUpdate()
    {
        Vector3 movement = new Vector3(movementX, 0.0f, movementY);
        rb.AddForce(movement * speed);
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.CompareTag("PickUp"))
        {
            other.gameObject.SetActive(false);
            count++;

            SetCountText();
        }
    }

    /// <summary>
    /// Creates a new peer connection and wires up the events we're interested in.
    /// Note that there is no logic to send local ICE candidates to the signalling server. That's because
    /// the offer SDP generated by the Unity libwebrtc wrapper puts the candidates in the offer SDP (i.e.
    /// it's not trickling them).
    /// </summary>
    private RTCPeerConnection CreatePeerConnection()
    {
        Debug.WriteLine("CreatePeerConnection");

        var pc = new RTCPeerConnection();

        pc.OnIceCandidate = candidate => Debug.WriteLine($"ICE candidate {candidate.candidate}.");
        pc.OnIceConnectionChange = state => Debug.WriteLine($"ICE connection state changed to {state}.");
        pc.OnNegotiationNeeded = () => Debug.WriteLine($"Negotiation needed, current state {pc.SignalingState}.");
        pc.OnTrack = e => Debug.WriteLine($"OnTrack {e.Track.Kind}.");

        return pc;
    }
}

public class WebRTCNodeDssPeer
{
    private const int NODE_SERVER_POLL_PERIOD = 500;    // Period in milliseconds to poll the node server to check for new messages.

    private Uri _nodeDssServerUri;
    private string _ourID;
    private string _theirID;
    private bool _isClosed;

    private RTCPeerConnection _pc;

    /// <summary>
    /// Default constructor.
    /// </summary>
    /// <param name="nodeDssServer">The base URI of the node Dead Simple Signalling (DSS) server.</param>
    /// <param name="ourID">The arbitrary ID this peer is using.</param>
    /// <param name="theirID">The arbitrary ID the remote peer is using.</param>
    /// <param name="createPeerConnection">Function delegate used to create a new WebRTC peer connection.</param>
    public WebRTCNodeDssPeer(
        string nodeDssServer,
        string ourID,
        string theirID,
        RTCPeerConnection peerConnection)
    {
        if (string.IsNullOrWhiteSpace(nodeDssServer))
        {
            throw new ArgumentNullException("The node DSS server URI must be supplied.");
        }

        if (string.IsNullOrWhiteSpace(ourID))
        {
            throw new ArgumentNullException("ourID");
        }

        if (string.IsNullOrWhiteSpace(theirID))
        {
            throw new ArgumentNullException("theirID");
        }

        _nodeDssServerUri = new Uri(nodeDssServer);
        _ourID = ourID;
        _theirID = theirID;
        _pc = peerConnection;
    }

    /// <summary>
    /// Creates a new WebRTC peer connection and send an SDP offer to the node DSS server.
    /// </summary>
    public IEnumerator Start()
    {
        var nodeDssClient = new HttpClient();

        Debug.WriteLine($"node-dss starting receive task for server {_nodeDssServerUri}, our ID {_ourID} and their ID {_theirID}.");

        RTCOfferOptions offerOptions = new RTCOfferOptions();
        var createOfferOp = _pc.CreateOffer(ref offerOptions);
        yield return createOfferOp;

        if (createOfferOp.IsError)
        {
            Debug.WriteLine($"Error creating local description on peer connection. {createOfferOp.Error}");
        }
        else
        {
            Debug.WriteLine($"Offer SDP: {createOfferOp.Desc.sdp}.");

            var init = createOfferOp.Desc;
            var setLocalOp = _pc.SetLocalDescription(ref init);
            yield return setLocalOp;

            if (setLocalOp.IsError)
            {
                Debug.WriteLine($"Error setting local description on peer connection. {setLocalOp.Error}");
            }
            else
            {
                Debug.WriteLine("node-dss sending initial SDP offer to server.");
                _ = Task.Run(() => ReceiveFromNSS(nodeDssClient, _pc));
            }
        }
    }

    public void Close()
    {
        _isClosed = true;
    }

    private async Task SendToNSS(HttpClient httpClient, string jsonStr)
    {
        var content = new StringContent(jsonStr, Encoding.UTF8, "application/json");
        var res = await httpClient.PostAsync($"{_nodeDssServerUri}data/{_theirID}", content);

        Debug.WriteLine($"node-dss POST result for {_nodeDssServerUri}data/{_theirID} {res.StatusCode}.");
    }

    private async Task ReceiveFromNSS(HttpClient httpClient, RTCPeerConnection pc)
    {
        try
        {
            // Send the SDP offer to the node-dss server so the remote peer can retrieve it.
            await SendToNSS(httpClient, pc.LocalDescription.toJSON());

            // The receive loop gets stopped as soon as ICE connection state completes or fails. At that
            // point there's no point waiting for anymore ICE candidates from the signalling server.
            while (!_isClosed 
                && (pc.IceConnectionState == RTCIceConnectionState.New || pc.IceConnectionState == RTCIceConnectionState.Checking))
            {
                var res = await httpClient.GetAsync($"{_nodeDssServerUri}data/{_ourID}");

                if (res.StatusCode == HttpStatusCode.OK)
                {
                    var content = await res.Content.ReadAsStringAsync();
                    if (!string.IsNullOrWhiteSpace(content))
                    {
                        OnMessage(content, pc);
                    }
                    else
                    {
                        await Task.Delay(NODE_SERVER_POLL_PERIOD);
                    }
                }
                else
                {
                    throw new ApplicationException($"Get request to node DSS server failed with response code {res.StatusCode}.");
                }
            }
        }
        finally
        {
            Debug.WriteLine("node-dss receive task exiting.");
        }
    }

    /// <summary>
    /// Process JSON messages received from the remote peer. The only messages will be the SDP answer and 
    /// ICE candidates.
    /// </summary>
    private void OnMessage(string jsonStr, RTCPeerConnection pc)
    {
        var msgType = JsonRTC.TryGetType(jsonStr);
        Debug.WriteLine($"JSON message type {msgType}.");

        switch (msgType)
        {
            case JsonRTC.JsonMessageType.IceCandidate:
                if (JsonRTC.TryParseIceCandidate(jsonStr, out var iceCandidateInit))
                {
                    Debug.WriteLine($"Got remote ICE candidate, {iceCandidateInit.candidate}.");
                    _pc.AddIceCandidate(ref iceCandidateInit);
                }
                break;
            case JsonRTC.JsonMessageType.SdpDescription:
                if (JsonRTC.TryParseDescription(jsonStr, out var desc))
                {
                    Debug.WriteLine($"Got remote SDP, type {desc.type}.");
                    Debug.WriteLine(desc.sdp);
                    var setRemoteOp = _pc.SetRemoteDescription(ref desc);
                    bool isDone = setRemoteOp.MoveNext();
                    Debug.WriteLine($"Set remote description is done {isDone}, error {setRemoteOp.IsError}, signalling state {pc.SignalingState}.");
                }
                break;
            default:
                Debug.WriteLine($"node-dss could not parse JSON message. {jsonStr}");
                break;
        }
    }
}

/// <summary>
/// Helper class to do JSON serialisation. The inbuilt UNity JsonUtility class doesn't seem to be able to 
/// serialise enum names which will results in the "sdp" type being set as 0 instead of "offer" etc.
/// </summary>
public static class JsonRTC
{
    public enum JsonMessageType
    {
        Unknown,
        SdpDescription,
        IceCandidate,
    }

    public static JsonMessageType TryGetType(string json)
    {
        if (Regex.Match(json, @"""candidate"":", RegexOptions.IgnoreCase).Success)
        {
            return JsonMessageType.IceCandidate;
        }
        else if (Regex.Match(json, @"""sdp"":", RegexOptions.IgnoreCase).Success)
        {
            return JsonMessageType.SdpDescription;
        }
        else
        {
            return JsonMessageType.Unknown;
        }
    }

    public static string toJSON(this RTCSessionDescription desc)
    {
        return "{" +
                 $"  \"type\": \"{desc.type.ToString().ToLower()}\"," +
                 $"  \"sdp\": \"{desc.sdp.Replace("\r\n", @"\r\n")}\"" +
                 "}";
    }

    public static string toJSON(this RTCIceCandidate candidate)
    {
        return "{" +
             $"  \"sdpMid\": \"{candidate.sdpMid ?? candidate.sdpMLineIndex.ToString()}\"," +
             $"  \"sdpMLineIndex\": {candidate.sdpMLineIndex}," +
             $"  \"usernameFragment\": \"\"," +
             $"  \"candidate\": \"{candidate.candidate}\"" +
             "}";
    }

    public static bool TryParseIceCandidate(string json, out RTCIceCandidate candidate)
    {
        candidate = new RTCIceCandidate();

        candidate.sdpMid = Regex.Match(json, @"""sdpMid"":\s*""(?<sdpMid>.*?)""", RegexOptions.IgnoreCase).Result("${sdpMid}");
        candidate.sdpMLineIndex = Convert.ToInt32(Regex.Match(json, @"""sdpMLineIndex"":\s*(?<sdpMLineIndex>\d+)", RegexOptions.IgnoreCase).Result("${sdpMLineIndex}"));
        candidate.candidate = Regex.Match(json, @"""candidate"":\s*""(?<candidate>.*?)""", RegexOptions.IgnoreCase).Result("${candidate}");

        return candidate.candidate != null;
    }

    public static bool TryParseDescription(string json, out RTCSessionDescription desc)
    {
        desc = new RTCSessionDescription();
        desc.type = (RTCSdpType)Enum.Parse(typeof(RTCSdpType), Regex.Match(json, @"""type"":\s*""(?<type>.*?)""", RegexOptions.IgnoreCase).Result("${type}"), true);
        desc.sdp = Regex.Match(json, @"""sdp"":\s*""(?<sdp>.*?)""", RegexOptions.IgnoreCase).Result("${sdp}").Replace(@"\r\n", "\r\n");

        return desc.sdp != null;
    }
}

